/***************************************************************************************************

 В этом файле находится шаблонный класс кольцевого буфера. Это блокирующая реализация, потокобезопасная.
 Она просто делает критическую секцию на каждый чих.

***************************************************************************************************/

#pragma once

#include "circular_buffer.h"

/**************************************************************************************************
Описание:  Класс кольцевого буфера

Аргументы: T - тип элемента буфера
           TBufSize - размер буфера

Замечания: Критические секции в каждой функции.
**************************************************************************************************/
template< typename T, uint32_t TBufSize>
class BlockingCircularBuffer
{

public:

    BlockingCircularBuffer() :
        circularBuffer()
    {
    }

    /**************************************************************************************************
    Описание:  Функция сброса
    Аргументы: -
    Возврат:   -
    Замечания: Просто обнуляет все счетчики
    **************************************************************************************************/
    void reset(void)
    {
        ENTER_CRITICAL_SECTION();
            circularBuffer.reset();
        EXIT_CRITICAL_SECTION();
    }

    /**************************************************************************************************
    Описание:  Запись элемента в начало буфера
    Аргументы: T elem - новый элемент
    Возврат:   -
    Замечания: -
    **************************************************************************************************/
    void writeHead(T elem)
    {
        ENTER_CRITICAL_SECTION();
            circularBuffer.writeHead(elem);
        EXIT_CRITICAL_SECTION();
    }

    /**************************************************************************************************
    Описание:  Чтение элемента с конца буфера
    Аргументы: -
    Возврат:   Прочитанный элемент
    Замечания: -
    **************************************************************************************************/
    T readTail( void )
    {
        T result;
        
        ENTER_CRITICAL_SECTION();
            result = circularBuffer.readTail();
        EXIT_CRITICAL_SECTION();
        
        return result;
    }

    /**************************************************************************************************
    Описание:  Пуст ли буфер?
    Аргументы: -
    Возврат:   true/false
    Замечания: -
    **************************************************************************************************/
    bool isEmpty(void) const
    {
        bool result;
        
        ENTER_CRITICAL_SECTION();
            result = circularBuffer.isEmpty();
        EXIT_CRITICAL_SECTION();
        
        return result;
    }

    /**************************************************************************************************
    Описание:  Полон ли буфер?
    Аргументы: -
    Возврат:   true/false
    Замечания: -
    **************************************************************************************************/
    bool isFull(void) const
    {
        bool result;
        
        ENTER_CRITICAL_SECTION();
            result = circularBuffer.isFull();
        EXIT_CRITICAL_SECTION();
        
        return result;
    }

    /**************************************************************************************************
    Описание:  Сколько элементов использовано
    Аргументы: -
    Возврат:   Количество использованных элементов
    Замечания: -
    **************************************************************************************************/
    uint32_t getUsedElemNum(void) const
    {
        uint32_t result;

        ENTER_CRITICAL_SECTION();
            result = circularBuffer.getUsedElemNum();
        EXIT_CRITICAL_SECTION();

        return result;
    }

    /**************************************************************************************************
    Описание:  Сколько элементов пусто
    Аргументы: -
    Возврат:   Количество пустых элементов
    Замечания: -
    **************************************************************************************************/
    uint32_t getFreeElemNum(void) const
    {
        uint32_t result;

        ENTER_CRITICAL_SECTION();
            result = circularBuffer.getFreeElemNum();
        EXIT_CRITICAL_SECTION();

        return result;
    }

    /**************************************************************************************************
    Описание:  Записать массив в кольцевой буфер
    Аргументы: newData - указатель на массив, который нужно записать
               size - сколько элементов нужно записать
    Возврат:   -
    Замечания: -
    **************************************************************************************************/
    void putData(const T * newData, uint32_t size)
    {
        ENTER_CRITICAL_SECTION();
            circularBuffer.putData(newData, size);
        EXIT_CRITICAL_SECTION();
    }

private:

    volatile CircularBuffer<T, TBufSize> circularBuffer;

};



