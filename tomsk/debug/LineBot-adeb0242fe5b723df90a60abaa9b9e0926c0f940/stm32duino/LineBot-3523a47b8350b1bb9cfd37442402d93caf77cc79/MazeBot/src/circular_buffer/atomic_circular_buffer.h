/***************************************************************************************************

 В этом файле находится шаблонный класс "атомарного" кольцевого буфера. Это _теоретически_
 потокобезопасная реализация, не использующая критические секции. 
 
 Только вот непонятно, как это проверять. Используйте на свой страх и риск!
 
 Предполагает, что буфером пользуется только 1 Читатель и 1 Писатель! Если их больше, то НИЧЕГО
 не гарантируется!

***************************************************************************************************/

#pragma once

#include <stdint.h>
#include <algorithm>
#include "project_config.h"
#include "umba_atomic/umba_atomic.h"

/**************************************************************************************************
Описание:  Класс кольцевого буфера

Аргументы: T - тип элемента буфера
           TBufSize - размер буфера

Замечания: Все функции помечены как volatile, чтобы их можно было вызывать для volatile экземпляра.
           Этот класс не предназначен для использования в прерываниях и вне прерываний,
           для этого используйте BlockingCircularBuffer!
**************************************************************************************************/
template< typename T, uint32_t TBufSize>
class AtomicCircularBuffer
{

public:

    AtomicCircularBuffer() : headPos(0),
                             tailPos(0),
                             count(0)
    {
    }

    /**************************************************************************************************
    Описание:  Функция сброса
    Аргументы: -
    Возврат:   -
    Замечания: Просто обнуляет все счетчики
    **************************************************************************************************/
    void reset(void) 
    {
        headPos = 0;
        tailPos = 0;
        count.store(0);
    }

    /**************************************************************************************************
    Описание:  Запись элемента в начало буфера
    Аргументы: T elem - новый элемент
    Возврат:   -
    Замечания: -
    **************************************************************************************************/
    void writeHead(T elem)
    {
        buffer[headPos] = elem;
        this->incHead();
        
        count.fetch_add(1);

        UMBA_ASSERT(count.load() <= TBufSize);
// 		// хвост обогнал голову - этого не должно происходить
//         UMBA_ASSERT( (tailPos + count) % TBufSize == headPos );
    }

    /**************************************************************************************************
    Описание:  Чтение элемента с конца буфера
    Аргументы: -
    Возврат:   Прочитанный элемент
    Замечания: -
    **************************************************************************************************/
    T readTail( void )
    {
        T elem = buffer[tailPos];
        incTail();
        
        count.fetch_sub(1);

        UMBA_ASSERT(count.load() <= TBufSize);
        
//        UMBA_ASSERT( (tailPos + count) % TBufSize == headPos );

        return elem;
    }

    /**************************************************************************************************
    Описание:  Пуст ли буфер?
    Аргументы: -
    Возврат:   true/false
    Замечания: -
    **************************************************************************************************/
    bool isEmpty(void) const
    {
// 		if(count == 0 && headPos != tailPos)
// 		{
// 			UMBA_ASSERT(true);
// 		}

        return count.load() == 0;
    }

    /**************************************************************************************************
    Описание:  Полон ли буфер?
    Аргументы: -
    Возврат:   true/false
    Замечания: -
    **************************************************************************************************/
    bool isFull(void) const
    {
        return count.load() == TBufSize;
    }

    /**************************************************************************************************
    Описание:  Сколько элементов использовано
    Аргументы: -
    Возврат:   Количество использованных элементов
    Замечания: -
    **************************************************************************************************/
    uint32_t getUsedElemNum(void) const
    {
        return count.load();
    }

    /**************************************************************************************************
    Описание:  Сколько элементов пусто
    Аргументы: -
    Возврат:   Количество пустых элементов
    Замечания: -
    **************************************************************************************************/
    uint32_t getFreeElemNum(void) const
    {
        return TBufSize - count.load();
    }

    /**************************************************************************************************
    Описание:  Записать массив в кольцевой буфер
    Аргументы: newData - указатель на массив, который нужно записать
               size - сколько элементов нужно записать
    Возврат:   -
    Замечания: -
    **************************************************************************************************/
    void putData(const T * newData, uint32_t size)
    {
        // не хватает места для записи
        UMBA_ASSERT( getFreeElemNum() >= size );

        // количество свободных ячеек в буфере до его "конца"
        uint32_t freeTillEnd = TBufSize - headPos;
        
        // сначала кладем данные
        // т.к. Писатель только один, пока мы их кладем места в буфере не убавится
        // а вот обманывать Читателя, сначала меняя счетчик, наверное неправильно
            
        // если новые данные влезают в буфер без закольцовки
        if( size < freeTillEnd )
        {
            // то просто добавим их как в обычный массив
            std::copy( newData, newData+size, buffer + headPos );
            headPos += size;
        }
        // если не влезают
        else
        {
            // то добавим часть до "конца" буфера		    
            std::copy(newData, newData+freeTillEnd, buffer + headPos );
            size -= freeTillEnd;

            // а остальное - с "начала"
            std::copy( newData+freeTillEnd, newData+freeTillEnd+size, buffer );
            headPos = size;
        }
        
        // потом модифицируем счетчик        
        count.fetch_add(size);

        return;
    }

private:

    // увеличить указатель для записи
    void incHead(void)
    {
        headPos++;
        headPos %= TBufSize;
    }

    // увеличить указатель для чтения
    void incTail(void)
    {
        tailPos++;
        tailPos %= TBufSize;
    }

    volatile T buffer[TBufSize];
    volatile uint32_t headPos;
    volatile uint32_t tailPos;
    
    umba::Atomic<uint32_t> count;

};
